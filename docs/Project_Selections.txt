==================================================
1. Port Configuration:
==================================================
| Service             | Port  |
| ------------------- | ----- |
| UI (admin)          | 3000  |
| Agent Service (ADK) | 3000  |
| Backend API         | 3000  |
| Ollama              | 11434 |

URLs:
- http://localhost:3000/admin        ‚Üí Admin UI
- http://localhost:3000/agent       ‚Üí Agent Service
- http://localhost:5000/api         ‚Üí Backend API
- http://localhost:11434            ‚Üí Ollama

Note: For prototype, Agent Service runs on same port 3000 as UI.

UI calls Agent ‚Üí Agent calls tools and API.


==================================================
2. Project Structure:
==================================================
ShopAgent/
‚îÇ
‚îú‚îÄ‚îÄ data/
‚îÇ   ‚îú‚îÄ‚îÄ dynamic/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ orders.json
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ products.json
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ workflow.state.json          # üß† Runtime state
‚îÇ   ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ seed/
‚îÇ       ‚îî‚îÄ‚îÄ ... (unchanged)
‚îÇ
‚îú‚îÄ‚îÄ docs/
‚îÇ   ‚îú‚îÄ‚îÄ COMPLETE_PROJECT_DOCUMENTATION.md
‚îÇ   ‚îú‚îÄ‚îÄ Project_Selections.txt
‚îÇ   ‚îú‚îÄ‚îÄ state-model.md                   # üÜï
‚îÇ   ‚îú‚îÄ‚îÄ observability.md                 # üÜï
‚îÇ   ‚îî‚îÄ‚îÄ agent-flow.md                    # üÜï
‚îÇ
‚îú‚îÄ‚îÄ public/                              # UI (unchanged)
‚îÇ   ‚îî‚îÄ‚îÄ ...
‚îÇ
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ __tests__/                       # (unchanged)
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ routes/                          # REST APIs (unchanged)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ orders.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ products.ts
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ promotions.ts
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ agent/                           # ü§ñ Agent Brain
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ admin.agent.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ planner.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ executor.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ prompt.builder.ts
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ context.manager.ts
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ mcp_tools/                           # üîß PROMPT TOOLS + GUARDS
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ orders.tool.ts               # read/update + guards
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ products.tool.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ promotions.tool.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ validation.guard.ts          # schema + value checks
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ price.guard.ts               # outlier detection
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ transition.guard.ts          # status rules
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ human.confirm.guard.ts       # HITL
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ state/                           # üß† Strong Persistence
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ state.manager.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ workflow.store.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ session.store.ts
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ state.types.ts
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ observability/                   # üìä Metrics + Tracing
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ metrics.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ tracer.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ logger.ts
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ correlation.ts
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ llm/                             # Ollama
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ollama.client.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ token.counter.ts
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ model.config.ts
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ types/                           # (unchanged)
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ utils/                           # (keep storage + errors)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ errors.ts
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ storage.ts
‚îÇ   ‚îÇ
‚îÇ   ‚îú
‚îÇ   ‚îî‚îÄ‚îÄ server.ts
‚îÇ
‚îú‚îÄ‚îÄ jest.config.js
‚îú‚îÄ‚îÄ package.json
‚îú‚îÄ‚îÄ README.md
‚îî‚îÄ‚îÄ tsconfig.json


==================================================
3. Agent Architecture:
==================================================
One ADK agent service with 4 logical agents internally:

ShopAgent (ADK Service)
 ‚îú‚îÄ‚îÄ PlannerAgent
 ‚îú‚îÄ‚îÄ ValidationAgent
 ‚îú‚îÄ‚îÄ ExecutionAgent
 ‚îî‚îÄ‚îÄ ExplanationAgent

==================================================
4. Agent Responsibilities:
==================================================
PlannerAgent:
- Intent detection
- Entity extraction
- Normalize user input

Examples:
"Change price of PD-1067 to $67"
‚Üí UPDATE_PRODUCT_PRICE
‚Üí sku=PD-1067
‚Üí newPrice=67

ValidationAgent:
- Schema validation
- Business rules
- Guardrails
- Risk detection

Examples:
- SKU exists?
- Price >= 0?
- Price deviation threshold?
- Order status transition valid?

ExecutionAgent:
- Calls backend APIs
- Updates JSON data
- Handles atomic writes

ExplanationAgent:
- Generates user-friendly explanations after actions
- Answers questions about session history and workflow state
- Explains what happened in a particular session
- Handles questions regardless of database updates
- Uses LLM to understand context and provide natural language responses
- Can answer questions like "What happened in this session?" or "What was the last action?"


==================================================
5. LLM Usage by Agent:
==================================================
PlannerAgent ‚Üí Uses LLM:
Why LLM is needed:
- Planner's main job is understanding natural language from the admin
- Tasks like intent detection, entity extraction, and ambiguity detection are language-heavy and hard to code deterministically
- Example: "Change the price of HP-BLK-001 to $320" ‚Üí extract intent (UPDATE_PRODUCT_PRICE) + entities (sku=HP-BLK-001, newPrice=320)
- Confidence scoring is also done here

Summary:
- LLM used: ‚úÖ Yes
- Reason: Natural language understanding, flexible parsing, context awareness

ValidationAgent ‚Üí Does NOT use LLM:
Why LLM is NOT needed:
- Validation is deterministic ‚Äî it checks:
  - Schema correctness (price > 0, SKU exists)
  - Business rules (price deviation threshold, allowed order transitions)
  - Risk scoring (e.g., PRICE_OUTLIER)
- These are rule-based checks and don't require LLM reasoning
- Using LLM here would:
  - Add unnecessary cost and latency
  - Make safety/risk checks less predictable

Summary:
- LLM used: ‚ùå No
- Reason: Deterministic business rules; LLM could be unsafe or slower

ExecutionAgent ‚Üí Does NOT use LLM:
Why LLM is NOT needed:
- Execution is about API calls / database updates
- It maps validated intents to endpoints and executes them
- All inputs are already verified by ValidationAgent, so LLM reasoning isn't required
- Using LLM here would:
  - Add unnecessary complexity
  - Introduce risk (LLM could hallucinate API payloads)

Summary:
- LLM used: ‚ùå No
- Reason: Purely deterministic action execution

ExplanationAgent ‚Üí Uses LLM:
Why LLM is needed:
- ExplanationAgent generates user-friendly, natural language explanations
- LLM enables dynamic, context-aware responses
- Provides human-like explanations for success, errors, and confirmations
- Can adapt explanations based on context and user understanding
- Answers questions about session history and workflow state
- Handles questions regardless of whether database updates occurred
- Can explain what happened in a particular session based on workflow state

Decision for your system:
- Uses LLM for natural language generation
- Provides rich, contextual explanations
- Enhances user experience with clear, helpful messages
- Answers user questions about session history (e.g., "What happened in this session?")
- Explains workflow state and actions taken

Summary:
- LLM used: ‚úÖ Yes
- Reason: Natural language generation and question answering require LLM for dynamic, context-aware explanations based on session history and workflow state

WorkflowAgent ‚Üí Does NOT use LLM:
Why LLM is NOT needed:
- WorkflowAgent is the orchestrator: Planner ‚Üí Validation ‚Üí Execution ‚Üí Response
- It decides sequence, retries, and HITL triggers
- All logic is deterministic; no language understanding needed

Summary:
- LLM used: ‚ùå No
- Reason: Orchestration is rule-based; predictable workflow is mandatory

LLM Usage Summary Table:
| Agent               | LLM Used?  | Why / Why Not                                                                    |
| ------------------- | ---------- | -------------------------------------------------------------------------------- |
| PlannerAgent        | ‚úÖ Yes      | Extract intent/entities from NL; confidence scoring; ambiguity detection         |
| ValidationAgent     | ‚ùå No       | Deterministic guardrails, risk checks, schema/business rules; safe & predictable |
| ExecutionAgent      | ‚ùå No       | Executes API calls; already validated; deterministic                             |
| ExplanationAgent    | ‚úÖ Yes      | Generates natural language explanations; dynamic, context-aware responses         |
| WorkflowAgent       | ‚ùå No       | Orchestrates sequence; rule-based; deterministic                                 |

Key Principle:
- LLM only where understanding language or reasoning about unstructured input is required
- Deterministic, safety-critical, or action-oriented steps never use LLM


==================================================
6. Agent Prompts (Concise):
==================================================
PlannerAgent Prompt:
You are a PlannerAgent for an e-commerce admin system. Extract intent and entities from user messages.

Your task:
1. Identify the intent (UPDATE_PRODUCT_PRICE, CANCEL_ORDER, UPDATE_ORDER_STATUS, etc.)
2. Extract entities (sku, orderNumber, price, status, etc.)
3. Return JSON: {"intent": "...", "entities": {...}, "confidence": 0.0-1.0}

Supported intents:
- UPDATE_PRODUCT_PRICE
- UPDATE_PRODUCT_DESCRIPTION
- CANCEL_ORDER
- UPDATE_ORDER_STATUS
- SHOW_PRODUCT_INFO
- SHOW_ORDER_INFO

Example:
Input: "Change price of HP-BLK-001 to $320"
Output: {"intent": "UPDATE_PRODUCT_PRICE", "entities": {"sku": "HP-BLK-001", "newPrice": 320}, "confidence": 0.95}


ValidationAgent Prompt:
You are a ValidationAgent. Validate business rules and detect risks.

Your task:
1. Check if entities exist (SKU, orderNumber)
2. Validate business rules (price >= 0, valid status transitions)
3. Calculate risk flags (PRICE_OUTLIER if deviation > 40%)
4. Return JSON: {"valid": true/false, "riskFlag": "...", "errors": [...]}

Guardrails:
- Price deviation > 40% ‚Üí PRICE_OUTLIER
- Price < 0 ‚Üí INVALID_PRICE
- SKU not found ‚Üí SKU_NOT_FOUND
- Invalid status transition ‚Üí INVALID_TRANSITION
- Order already shipped ‚Üí CANNOT_CANCEL_SHIPPED

Example:
Input: {"intent": "UPDATE_PRODUCT_PRICE", "entities": {"sku": "HP-BLK-001", "newPrice": 67}, "oldPrice": 890}
Output: {"valid": false, "riskFlag": "PRICE_OUTLIER", "errors": ["Price deviation 92% exceeds 40% threshold"]}


ExecutionAgent Prompt:
You are an ExecutionAgent. Execute validated actions via API calls.

Your task:
1. Map intent to API endpoint
2. Construct API request payload
3. Call backend API (http://localhost:5000/api)
4. Handle errors and retries
5. Return JSON: {"success": true/false, "data": {...}, "error": "..."}

API Endpoints:
- UPDATE_PRODUCT_PRICE ‚Üí PUT /api/v1/products/{sku}/price
- CANCEL_ORDER ‚Üí PUT /api/v1/orders/{orderNumber}/cancel
- UPDATE_ORDER_STATUS ‚Üí PUT /api/v1/orders/{orderNumber}/status

Example:
Input: {"intent": "UPDATE_PRODUCT_PRICE", "entities": {"sku": "HP-BLK-001", "newPrice": 320}, "confirmed": true}
Output: {"success": true, "data": {"sku": "HP-BLK-001", "oldPrice": 299.99, "newPrice": 320}}


ExplanationAgent Prompt:
You are an ExplanationAgent. Generate user-friendly, natural language explanations and answer questions about session history.

Your task:
1. Generate clear success messages after actions
2. Create helpful confirmation prompts for risky actions
3. Explain errors in plain, understandable language
4. Include relevant details (order numbers, SKUs, prices) in context
5. Answer questions about what happened in the session
6. Explain workflow state and actions taken
7. Provide context-aware responses based on session history
8. Handle questions regardless of whether database updates occurred

Response types:
- Success: "‚úÖ Successfully updated price of HP-BLK-001 from $299.99 to $320"
- Confirmation needed: "‚ö†Ô∏è Large price change detected (92% drop). Please confirm: 'CONFIRM price change for HP-BLK-001 to $67'"
- Error: "‚ùå Error: Product SKU-9999 not found. Please check the SKU and try again."

Example:
Input: {"success": true, "intent": "UPDATE_PRODUCT_PRICE", "data": {"sku": "HP-BLK-001", "oldPrice": 299.99, "newPrice": 320}}
Output: "‚úÖ Successfully updated the price of Premium Wireless Headphones (HP-BLK-001) from $299.99 to $320."


Agent Output Examples:
======================
PlannerAgent Output:
{
  "intent": "UPDATE_PRODUCT_PRICE",
  "entities": {
    "sku": "HP-BLK-001",
    "newPrice": 320
  },
  "confidence": 0.95,
  "timestamp": "2026-01-29T10:11:00.045Z",
  "traceId": "t-101",
  "workflowId": "SHOP-7788"
}

ValidationAgent Output (Success):
{
  "valid": true,
  "riskFlag": null,
  "errors": [],
  "entityExists": true,
  "businessRulesPassed": true,
  "timestamp": "2026-01-29T10:11:00.120Z",
  "traceId": "t-101",
  "workflowId": "SHOP-7788"
}

ValidationAgent Output (Price Outlier):
{
  "valid": false,
  "riskFlag": "PRICE_OUTLIER",
  "errors": ["Price deviation 92% exceeds 40% threshold"],
  "entityExists": true,
  "businessRulesPassed": false,
  "oldPrice": 890,
  "newPrice": 67,
  "deviationPercent": 92.47,
  "requiresConfirmation": true,
  "timestamp": "2026-01-29T10:11:00.120Z",
  "traceId": "t-101",
  "workflowId": "SHOP-7788"
}

ValidationAgent Output (SKU Not Found):
{
  "valid": false,
  "riskFlag": "SKU_NOT_FOUND",
  "errors": ["Product with SKU SKU-9999 not found"],
  "entityExists": false,
  "businessRulesPassed": false,
  "requiresConfirmation": false,
  "timestamp": "2026-01-29T10:11:00.120Z",
  "traceId": "t-101",
  "workflowId": "SHOP-7788"
}

ExecutionAgent Output (Success):
{
  "success": true,
  "data": {
    "sku": "HP-BLK-001",
    "oldPrice": 299.99,
    "newPrice": 320,
    "productName": "Premium Wireless Headphones",
    "updatedAt": "2026-01-29T10:11:00.280Z"
  },
  "error": null,
  "apiResponse": {
    "statusCode": 200,
    "message": "Product price updated successfully"
  },
  "timestamp": "2026-01-29T10:11:00.280Z",
  "traceId": "t-101",
  "workflowId": "SHOP-7788"
}

ExecutionAgent Output (API Error):
{
  "success": false,
  "data": null,
  "error": "API request failed: Product not found",
  "apiResponse": {
    "statusCode": 404,
    "message": "Product with SKU HP-BLK-999 not found"
  },
  "timestamp": "2026-01-29T10:11:00.280Z",
  "traceId": "t-101",
  "workflowId": "SHOP-7788"
}

ExplanationAgent Output (Success):
"‚úÖ Successfully updated the price of Premium Wireless Headphones (HP-BLK-001) from $299.99 to $320."

ExplanationAgent Output (Confirmation Needed):
"‚ö†Ô∏è This is a large price change (from $890 ‚Üí $67, 92% drop).

Please confirm:
'CONFIRM price change for HP-BLK-001 to $67'"

ExplanationAgent Output (Error):
"‚ùå Error: Product SKU-9999 not found. Please check the SKU and try again."

ExplanationAgent Output (Order Cancelled):
"‚úÖ Successfully cancelled order ORD-1001. The order status has been updated to 'cancelled'."

ExplanationAgent Output (Invalid Transition):
"‚ùå Error: Cannot cancel order ORD-2001. This order has already been shipped and cannot be cancelled."


==================================================
7. System Flow:
==================================================
Admin UI
   ‚Üì
Agent Service (Planner ‚Üí Validator ‚Üí Executor ‚Üí Responder)
   ‚Üì
Backend API (/api)
   ‚Üì
JSON Storage

Every request has:
- traceId
- workflowId
- sessionId


==================================================
8. Development Flow:
==================================================
1. Define the Goal & Scope
   ‚Üì
2. Design the Agent & Interactions
   ‚Üì
3. Build Agents & Tools
   ‚Üì
4. Configure & Connect
   ‚Üì
5. Local Run & Debug
   ‚Üì
6. Evaluate & Iterate
   ‚Üì (feedback loop back to step 3)
7. Deploy

Detailed Steps:

1. Define the Goal & Scope:
   - E-commerce admin assistant for single administrator
   - Natural language interface for store management
   - Support: product updates, order management, promotions
   - Human-in-the-loop for high-risk actions (price outliers > 40%)
   - Prototype scope: UI + Agent + Backend on port 3000

2. Design the Agent & Interactions:
   - 4 logical agents: PlannerAgent, ValidationAgent, ExecutionAgent, ExplanationAgent
   - Agent flow: Planner ‚Üí Validator ‚Üí Executor ‚Üí Responder
   - Define prompts for each agent
   - Design guardrails and business rules
   - Define state persistence strategy

3. Build Agents & Tools:
   - Implement agent logic (src/agent/)
   - Build tools and guards (src/tools/)
   - Create state management (src/state/)
   - Set up observability (src/observability/)
   - Integrate Ollama LLM (src/llm/)

4. Configure & Connect:
   - Configure ports (UI: 3000, API: 5000, Ollama: 11434)
   - Connect agent to backend API
   - Set up state persistence (workflow.state.json)
   - Configure metrics and tracing
   - Set up prompt registry

5. Local Run & Debug:
   - Start Ollama service
   - Run backend API (port 5000)
   - Run agent service (port 3000)
   - Test agent interactions
   - Debug using trace logs and metrics
   - Test guardrails and edge cases

6. Evaluate & Iterate:
   - Review agent responses
   - Check metrics and performance
   - Test guardrail effectiveness
   - Validate human-in-the-loop flow
   - Iterate on prompts and tools
   - Feedback loop: Return to step 3 (Build Agents & Tools) for improvements

7. Deploy:
   - Finalize code
   - Run comprehensive tests
   - Deploy to production environment
   - Monitor metrics and logs


==================================================
9. Customer View:
==================================================
- URL: http://localhost:3000/
- This is only read-only page
- Customer can view the products and order history
          - Read-only storefront for browsing products
- Included for realism and data generation


==================================================
10. Admin UI:
==================================================
- URL: http://localhost:3000/admin
- This is the admin page where admin can see the recent orders
           - Displays:
           - Recent orders
           - Product catalog
           - Allows:
               - Updating order status
               - Editing product details (name, description, price)
- You will extend this page by embedding a chatbot interface that allows an administrator to manage the store using natural language.


==================================================
11. Backend API:
==================================================
- Base URL: http://localhost:5000/api
- Full API documentation available at http://localhost:5000/api
- We can extend this API by keeping the "http://localhost:5000/api/v1/orders" where we can modify and basically interact with agents and modify the order details
- We can extend this API by keeping the products information on "http://localhost:5000/api/v1/products" on this endpoints basically what we do is we can change the product info through the agents
- Chat endpoint: http://localhost:5000/api/chat


==================================================
12. Model Selected:
==================================================
- Model: ollama pull qwen3-coder:30b
- Source: https://ollama.com/library/qwen3-coder:30b (19GB)
- I downloaded the latest AI qwen3:30b parameter model because it supports the thinking and coder activities and especially it is designed for agent workflows


==================================================
13. Traceability Model (Mandatory):
==================================================
Every request generates:
- traceId = uuid()
- workflowId = `SHOP-${Date.now()}`
- sessionId = browser session
- workflowTimestampStart = ISO timestamp when workflow begins
- workflowTimestampEnd = ISO timestamp when workflow completes

Propagated across:
UI ‚Üí Agent ‚Üí API ‚Üí Storage ‚Üí Logs

Audit Fields:
- userId (admin identifier)
- action (intent/operation performed)
- entityType (product, order, etc.)
- entityId (SKU, orderNumber, etc.)
- oldValue (before change)
- newValue (after change)
- status (success, failed, pending_confirmation)
- errorMessage (if failed)

Example Trace Log:
{
  "traceId": "t-91283",
  "workflowId": "SHOP-77822",
  "sessionId": "sess-abc123",
  "workflowTimestampStart": "2026-01-29T10:11:00.000Z",
  "workflowTimestampEnd": "2026-01-29T10:11:00.340Z",
  "agent": "ValidationAgent",
  "intent": "UPDATE_PRODUCT_PRICE",
  "userId": "admin",
  "action": "UPDATE_PRODUCT_PRICE",
  "entityType": "product",
  "entityId": "PD-1067",
  "sku": "PD-1067",
  "oldPrice": 890,
  "newPrice": 67,
  "oldValue": 890,
  "newValue": 67,
  "riskFlag": "PRICE_OUTLIER",
  "status": "pending_confirmation",
  "timestamp": "2026-01-29T10:11:00Z"
}


==================================================
14. Metrics - What to Capture and Where to Store:
==================================================
Where to Store Metrics:
For assignment:
- /metrics/metrics.json (append)
- Console logs

Optional bonus:
- SQLite

Workflow Metrics:
| Metric           | Example   |
| ---------------- | --------- |
| workflow_id      | SHOP-9912 |
| trace_id         | t-111     |
| total_latency_ms | 340       |
| success          | true      |
| retries          | 0         |
| agent_steps      | 4         |

LLM Metrics:
| Metric            | Example |
| ----------------- | ------- |
| prompt_tokens     | 412     |
| completion_tokens | 91      |
| context_usage_pct | 32%     |
| latency_ms        | 220     |
| retry_count       | 0       |

Agent Metrics:
| Metric                     | Example       |
| -------------------------- | ------------- |
| intent_confidence          | 0.94          |
| schema_validation_failures | 0             |
| guardrail_triggers         | PRICE_OUTLIER |
| tool_calls                 | 1             |

API Metrics:
| Metric         | Example |
| -------------- | ------- |
| api_latency_ms | 41      |
| file_write_ms  | 12      |
| errors         | 0       |

MetricsEvent Schema:
File: /metrics/metrics.jsonl   (append only)

{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "MetricsEvent",
  "type": "object",
  "required": [
    "traceId",
    "workflowId",
    "sessionId",
    "timestamp",
    "layer",
    "metrics"
  ],
  "properties": {
    "traceId": { "type": "string" },
    "workflowId": { "type": "string" },
    "sessionId": { "type": "string" },
    "timestamp": { "type": "string", "format": "date-time" },
    "layer": {
      "type": "string",
      "enum": ["WORKFLOW", "PLANNER_AGENT", "VALIDATION_AGENT", "EXECUTION_AGENT", "EXPLANATION_AGENT", "LLM", "API"]
    },
    "metrics": {
      "type": "object",
      "properties": {
        "workflow": {
          "type": "object",
          "properties": {
            "workflow_id": { "type": "string" },
            "trace_id": { "type": "string" },
            "total_latency_ms": { "type": "number" },
            "success": { "type": "boolean" },
            "retries": { "type": "number" },
            "agent_steps": { "type": "number" },
            "workflowTimestampStart": { "type": "string", "format": "date-time" },
            "workflowTimestampEnd": { "type": "string", "format": "date-time" }
          }
        },
        "plannerAgent": {
          "type": "object",
          "properties": {
            "timestampStart": { "type": "string", "format": "date-time" },
            "timestampCompleted": { "type": "string", "format": "date-time" },
            "latency_ms": { "type": "number" },
            "intent": { "type": "string" },
            "intent_confidence": { "type": "number" },
            "entities_extracted": { "type": "number" },
            "llm_calls": { "type": "number" },
            "errors": { "type": "number" }
          }
        },
        "validationAgent": {
          "type": "object",
          "properties": {
            "timestampStart": { "type": "string", "format": "date-time" },
            "timestampCompleted": { "type": "string", "format": "date-time" },
            "latency_ms": { "type": "number" },
            "schema_validation_failures": { "type": "number" },
            "guardrail_triggers": { "type": "array", "items": { "type": "string" } },
            "risk_flags": { "type": "array", "items": { "type": "string" } },
            "validation_passed": { "type": "boolean" },
            "errors": { "type": "number" }
          }
        },
        "executionAgent": {
          "type": "object",
          "properties": {
            "timestampStart": { "type": "string", "format": "date-time" },
            "timestampCompleted": { "type": "string", "format": "date-time" },
            "latency_ms": { "type": "number" },
            "tool_calls": { "type": "number" },
            "api_calls": { "type": "number" },
            "api_success": { "type": "boolean" },
            "data_updated": { "type": "boolean" },
            "errors": { "type": "number" }
          }
        },
        "explanationAgent": {
          "type": "object",
          "properties": {
            "timestampStart": { "type": "string", "format": "date-time" },
            "timestampCompleted": { "type": "string", "format": "date-time" },
            "latency_ms": { "type": "number" },
            "response_type": { "type": "string", "enum": ["success", "confirmation", "error"] },
            "message_length": { "type": "number" },
            "errors": { "type": "number" }
          }
        },
        "llm": {
          "type": "object",
          "properties": {
            "prompt_tokens": { "type": "number" },
            "completion_tokens": { "type": "number" },
            "total_tokens": { "type": "number" },
            "context_usage_pct": { "type": "number" },
            "latency_ms": { "type": "number" },
            "retry_count": { "type": "number" },
            "model": { "type": "string" }
          }
        },
        "api": {
          "type": "object",
          "properties": {
            "api_latency_ms": { "type": "number" },
            "file_write_ms": { "type": "number" },
            "endpoint": { "type": "string" },
            "method": { "type": "string" },
            "status_code": { "type": "number" },
            "errors": { "type": "number" }
          }
        }
      },
      "additionalProperties": false
    }
  }
}

Example Metrics Entries:

Workflow Metric:
{
  "traceId": "t-101",
  "workflowId": "SHOP-7788",
  "sessionId": "sess-abc123",
  "timestamp": "2026-01-29T10:11:00.340Z",
  "layer": "WORKFLOW",
  "metrics": {
    "workflow": {
      "workflow_id": "SHOP-7788",
      "trace_id": "t-101",
      "total_latency_ms": 340,
      "success": true,
      "retries": 0,
      "agent_steps": 4,
      "workflowTimestampStart": "2026-01-29T10:11:00.000Z",
      "workflowTimestampEnd": "2026-01-29T10:11:00.340Z"
    }
  }
}

PlannerAgent Metric:
{
  "traceId": "t-101",
  "workflowId": "SHOP-7788",
  "sessionId": "sess-abc123",
  "timestamp": "2026-01-29T10:11:00.045Z",
  "layer": "PLANNER_AGENT",
  "metrics": {
    "plannerAgent": {
      "timestampStart": "2026-01-29T10:11:00.000Z",
      "timestampCompleted": "2026-01-29T10:11:00.045Z",
      "latency_ms": 45,
      "intent": "UPDATE_PRODUCT_PRICE",
      "intent_confidence": 0.94,
      "entities_extracted": 2,
      "llm_calls": 1,
      "errors": 0
    },
    "llm": {
      "prompt_tokens": 412,
      "completion_tokens": 91,
      "total_tokens": 503,
      "context_usage_pct": 32,
      "latency_ms": 40,
      "retry_count": 0,
      "model": "qwen3-coder:30b"
    }
  }
}

ValidationAgent Metric:
{
  "traceId": "t-101",
  "workflowId": "SHOP-7788",
  "sessionId": "sess-abc123",
  "timestamp": "2026-01-29T10:11:00.120Z",
  "layer": "VALIDATION_AGENT",
  "metrics": {
    "validationAgent": {
      "timestampStart": "2026-01-29T10:11:00.045Z",
      "timestampCompleted": "2026-01-29T10:11:00.120Z",
      "latency_ms": 75,
      "schema_validation_failures": 0,
      "guardrail_triggers": ["PRICE_OUTLIER"],
      "risk_flags": ["PRICE_OUTLIER"],
      "validation_passed": false,
      "errors": 0
    }
  }
}

ExecutionAgent Metric:
{
  "traceId": "t-101",
  "workflowId": "SHOP-7788",
  "sessionId": "sess-abc123",
  "timestamp": "2026-01-29T10:11:00.280Z",
  "layer": "EXECUTION_AGENT",
  "metrics": {
    "executionAgent": {
      "timestampStart": "2026-01-29T10:11:00.120Z",
      "timestampCompleted": "2026-01-29T10:11:00.280Z",
      "latency_ms": 160,
      "tool_calls": 1,
      "api_calls": 1,
      "api_success": true,
      "data_updated": true,
      "errors": 0
    },
    "api": {
      "api_latency_ms": 41,
      "file_write_ms": 12,
      "endpoint": "/api/v1/products/HP-BLK-001/price",
      "method": "PUT",
      "status_code": 200,
      "errors": 0
    }
  }
}

ExplanationAgent Metric:
{
  "traceId": "t-101",
  "workflowId": "SHOP-7788",
  "sessionId": "sess-abc123",
  "timestamp": "2026-01-29T10:11:00.340Z",
  "layer": "EXPLANATION_AGENT",
  "metrics": {
    "responseAgent": {
      "timestampStart": "2026-01-29T10:11:00.280Z",
      "timestampCompleted": "2026-01-29T10:11:00.340Z",
      "latency_ms": 60,
      "response_type": "success",
      "message_length": 87,
      "errors": 0
    }
  }
}

LLM Metric (Standalone):
{
  "traceId": "t-101",
  "workflowId": "SHOP-7788",
  "sessionId": "sess-abc123",
  "timestamp": "2026-01-29T10:11:00.085Z",
  "layer": "LLM",
  "metrics": {
    "llm": {
      "prompt_tokens": 412,
      "completion_tokens": 91,
      "total_tokens": 503,
      "context_usage_pct": 32,
      "latency_ms": 220,
      "retry_count": 0,
      "model": "qwen3-coder:30b"
    }
  }
}

API Metric (Standalone):
{
  "traceId": "t-101",
  "workflowId": "SHOP-7788",
  "sessionId": "sess-abc123",
  "timestamp": "2026-01-29T10:11:00.161Z",
  "layer": "API",
  "metrics": {
    "api": {
      "api_latency_ms": 41,
      "file_write_ms": 12,
      "endpoint": "/api/v1/products/HP-BLK-001/price",
      "method": "PUT",
      "status_code": 200,
      "errors": 0
    }
  }
}


==================================================
15. Prompt Registry (Versioned):
==================================================
Create:
/prompts/
   planner.v1.txt
   planner.v2.txt

planner.v1 (Simple):
- Extract intent
- Extract entities
- JSON output only

planner.v2 (Improved):
Adds:
- Confidence score
- Ambiguity detection
- Missing field detection

Why Version Prompts:
- Reproducibility
- Rollback
- A/B testing
- Auditability

In code:
const ACTIVE_PROMPT = "planner.v2";


==================================================
16. Guardrails (Business + AI):
==================================================
Price Outlier Guardrail:
Rule:
If |newPrice - oldPrice| / oldPrice > 40% ‚Üí Require confirmation

Example:
Old price = 890
New price = 67
Deviation = 92%
‚Üí BLOCK + Ask confirmation

Agent Response:
‚ö†Ô∏è This is a large price change (from $890 ‚Üí $67, 92% drop).

Please confirm:
"CONFIRM price change for PD-1067 to $67"

Product Guardrails:
| Rule                  | Action             |
| --------------------- | ------------------ |
| SKU not found         | Reject             |
| price < 0             | Reject             |
| price < costPrice     | Warn               |
| price deviation > 40% | Human confirmation |
| product inactive      | Reject             |
| Description length limit | Reject (if exceeds) |
| Status active only    | Reject (if inactive) |

Order Guardrails:
| Rule                      | Action |
| ------------------------- | ------ |
| Order not found           | Reject |
| Invalid status transition | Reject |
| Already shipped ‚Üí cancel  | Reject |

Valid Order Transitions:
- pending ‚Üí shipped
- pending ‚Üí cancelled
- shipped ‚Üí delivered

Cannot cancel shipped orders.

LLM Guardrails:
| Rule               | Action     |
| ------------------ | ---------- |
| JSON parse fails   | Retry once |
| Schema invalid     | Reject     |
| Hallucinated field | Reject     |


==================================================
17. Human-in-the-Loop Flow (Price Outlier):
==================================================
Guardrail Rule:
ABS(newPrice - oldPrice) / oldPrice > 40%

Example:
Old price = 890
New price = 67
Deviation = 92%  ‚Üí BLOCK

Flow:
User Request
   ‚Üì
Planner extracts intent
   ‚Üì
Validator detects PRICE_OUTLIER
   ‚Üì
State saved with pendingConfirmation = true
   ‚Üì
Agent responds:
   "Please confirm price change"
   ‚Üì
User confirms:
   "CONFIRM price change for PD-1067 to $67"
   ‚Üì
Agent loads state
   ‚Üì
Executes update


==================================================
18. Human-in-the-Loop (HITL) Implementation:
==================================================
What We Are Trying to Achieve:
- Run guardrails + validations
- Measure confidence / risk / edge cases
- If thresholds fail or look risky ‚Üí pause execution
- Introduce a human to review or approve
- Resume workflow safely after approval

Key Rule:
‚ùó Human-in-the-Loop is NOT a new agent type in ADK
‚ùó It is a workflow state + decision point
‚ùó You do NOT create a separate "HumanAgent"

Where HITL Belongs in Workflow:
Planner (LLM)
   ‚Üì
Guardrails + Validation
   ‚Üì
Decision Gate (Thresholds)
   ‚îú‚îÄ‚îÄ PASS ‚Üí Execute
   ‚îî‚îÄ‚îÄ FAIL / RISK ‚Üí Human-in-the-Loop
                          ‚Üì
                     Approve / Reject / Modify
                          ‚Üì
                       Execute or Stop

This fits perfectly inside a Sequential Workflow Agent.

Metrics That Trigger Human-in-the-Loop:

1. Intent Confidence Score:
From PlannerAgent:
intent_confidence < 0.75
‚û°Ô∏è HITL required

2. Entity Extraction Confidence:
Missing or ambiguous entities:
{
  "product_id": null,
  "order_id": "ambiguous"
}
‚û°Ô∏è HITL required

3. Guardrail Violations:
Examples:
- Price change > 20%
- Order cancellation after shipping
- Inventory set to negative
‚û°Ô∏è HITL required

4. High-Risk Operations:
Even with high confidence:

| Action          | HITL |
| --------------- | ---- |
| Refund          | Yes  |
| Price update    | Yes  |
| Delete product  | Yes  |
| Inventory reset | Yes  |

5. Edge-Case Detection:
Examples:
- Multiple valid intents detected
- Conflicting parameters
- LLM uncertainty flag
‚û°Ô∏è HITL required

How to Implement This Cleanly (ADK-style):

Step 1: Validation Agent returns a decision:
{
  "status": "HITL_REQUIRED",
  "reason": "Price change exceeds threshold",
  "risk_score": 0.82
}
No LLM here. Deterministic.

Step 2: Workflow Agent pauses execution:
Workflow sets:
state = "WAITING_FOR_HUMAN_APPROVAL"
Nothing continues automatically.

Step 3: Human reviews (UI / Admin Panel):
Human can:
- Approve
- Reject
- Modify parameters
This is outside ADK (UI / API).

Step 4: Resume workflow:
When approval arrives:
{
  "approved": true,
  "modified_price": 49.99
}
Workflow resumes ‚Üí ExecutionAgent

Do You Need a Loop Agent for This?
‚ùå No

Why?
- You are waiting on an external event
- Not retrying LLM calls
- Not looping internally
Correct pattern = stateful pause + resume

Threshold Design:
| Metric              | Threshold | Action |
| ------------------- | --------- | ------ |
| Intent confidence   | < 0.75    | HITL   |
| Entity completeness | < 100%    | HITL   |
| Risk score          | > 0.6     | HITL   |
| Price change        | > 15‚Äì20%  | HITL   |
| Destructive action  | Any       | HITL   |

Common Mistake (You Are Avoiding It):
‚ùå Letting LLM decide whether human is needed
‚ùå Asking LLM "Should I ask a human?"

‚úÖ Correct:
- LLM gives signals
- Workflow + rules decide
This is enterprise-grade safety.

How to Explain This Simply (Interview-Ready):
"We use deterministic guardrails and thresholds after intent extraction.
If confidence, risk, or edge-case checks fail, the workflow transitions into a human-approval state.
Execution resumes only after explicit approval."

Final Confirmation:
‚úî Yes, you should introduce Human-in-the-Loop
‚úî Based on metrics + thresholds, not intuition
‚úî Implemented as workflow pause, not new agent
‚úî Fits perfectly inside Sequential Workflow Agent
‚úî No Parallel / Loop agent needed


==================================================
19. Possible Admin Questions (Based on Data):
==================================================
Products:
‚úî Change price
‚úî Update description
‚úî Show product info
‚úî Check inventory level
‚úî Check category
‚úî Show promotions applied

Orders:
‚úî Cancel order
‚úî Mark shipped
‚úî Show order details
‚úî Check shipment status
‚úî View line items

Promotions (Optional):
‚úî Activate promotion
‚úî Disable promotion
‚úî Check usage


==================================================
20. Success Paths:
==================================================
Example: Price Update (Normal):
Admin ‚Üí "Change price of HP-BLK-001 to $320"
Validation ‚Üí OK (within threshold)
Execution ‚Üí Update JSON
Response ‚Üí Success confirmation
Metrics ‚Üí Logged

Example: Cancel Order:
Admin ‚Üí "Cancel order ORD-1001"
Validation ‚Üí status = pending
Execution ‚Üí Update status
Response ‚Üí Success


==================================================
21. Failure Paths (Edge Cases):
==================================================
SKU Not Found:
"Change price of SKU-9999 to $50"
‚Üí Product not found

Negative Price:
"Change price of SKU-001 to -10"
‚Üí Validation error

Invalid Order Transition:
"Cancel shipped order ORD-2001"
‚Üí Not allowed

Large Price Outlier (Human Confirmation):
"Change price of PD-1067 to $67"
‚Üí Block + ask confirmation

LLM Output Invalid:
LLM call ‚Üí Schema invalid ‚Üí Retry once ‚Üí
Fail ‚Üí Fallback response


==================================================
22. Edge Case Flow Matrix:
==================================================
1. Price Outlier (Human Loop):
Request ‚Üí Validator detects outlier ‚Üí Save state ‚Üí
Ask confirmation ‚Üí Wait ‚Üí Confirm ‚Üí Execute

2. SKU Not Found:
Request ‚Üí Validator fails ‚Üí Error response ‚Üí END

3. Negative Price:
Request ‚Üí Validator fails ‚Üí Error response ‚Üí END

4. Order Already Shipped:
Request ‚Üí Validator fails ‚Üí Explain restriction ‚Üí END

5. LLM Output Invalid:
LLM call ‚Üí Schema invalid ‚Üí Retry once ‚Üí
Fail ‚Üí Fallback response


==================================================
23. State Persistence Strategy:
==================================================
For assignment:
In-memory Map + JSON snapshot

Store:
- sessionId
- pendingConfirmation
- lastIntent
- pendingPayload

File: /state/workflow_state.json

WorkflowState Schema:
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "WorkflowState",
  "type": "object",
  "required": [
    "sessionId",
    "workflowId",
    "traceId",
    "status",
    "updatedAt"
  ],
  "properties": {
    "sessionId": { "type": "string" },
    "workflowId": { "type": "string" },
    "traceId": { "type": "string" },
    "status": {
      "type": "string",
      "enum": ["IDLE", "PENDING_CONFIRMATION", "EXECUTING", "COMPLETED", "FAILED"]
    },
    "pendingAction": {
      "type": ["object", "null"],
      "properties": {
        "intent": { "type": "string" },
        "entity": { "type": "object" },
        "riskFlag": { "type": "string" },
        "originalValue": { "type": "number" },
        "requestedValue": { "type": "number" }
      }
    },
    "conversationSummary": { "type": "string" },
    "metricsSnapshot": {
      "type": "object",
      "properties": {
        "llmTokens": { "type": "number" },
        "latencyMs": { "type": "number" }
      }
    },
    "updatedAt": { "type": "string", "format": "date-time" }
  }
}


==================================================
24. Workflow State Machine:
==================================================
IDLE
  ‚Üì
EXECUTING
  ‚Üì
PENDING_CONFIRMATION (optional)
  ‚Üì
EXECUTING
  ‚Üì
COMPLETED
  ‚Üì
IDLE

Failure goes to:
FAILED ‚Üí IDLE


==================================================
25. Folder Additions:
==================================================
/metrics
/prompts
/state
/logs


==================================================
26. Debug Walkthrough - Notebook Style:
==================================================
Scenario 1: Normal Price Update (Happy Path)

User Input (Admin UI):
"Change price of HP-BLK-001 to $320"

Cell 1 ‚Äî Request Enters the System:
Entry Point:
- UI ‚Üí POST /agent/chat
- Session ID already exists (browser)
- Backend middleware injects:

{
  "traceId": "t-101",
  "workflowId": "SHOP-7788",
  "sessionId": "sess-abc123"
}

üìå Debug Tip:
- If nothing works ‚Üí check server.ts middleware
- First thing you always log: traceId + workflowId

Cell 2 ‚Äî PlannerAgent (LLM):
Input to PlannerAgent:
{
  "message": "Change price of HP-BLK-001 to $320",
  "context": {
    "sessionId": "sess-abc123"
  }
}

What PlannerAgent Does:
- Calls LLM (Ollama qwen3-coder:30b)
- Uses planner.v2 prompt
- Extracts: Intent, Entities, Confidence

Output:
{
  "intent": "UPDATE_PRODUCT_PRICE",
  "entities": {
    "sku": "HP-BLK-001",
    "newPrice": 320
  },
  "confidence": 0.94,
  "timestamp": "2026-01-29T10:11:00.045Z",
  "traceId": "t-101",
  "workflowId": "SHOP-7788"
}

Metrics Logged:
{
  "layer": "PLANNER_AGENT",
  "intent_confidence": 0.94,
  "llm_calls": 1
}

üìå Debug Tips:
- Wrong intent? ‚Üí open /prompts/planner.v2.txt
- Low confidence? ‚Üí check ambiguity or missing entities
- LLM slow? ‚Üí check ollama.client.ts latency

Cell 3 ‚Äî ValidationAgent (NO LLM):
Input to ValidationAgent:
{
  "intent": "UPDATE_PRODUCT_PRICE",
  "entities": {
    "sku": "HP-BLK-001",
    "newPrice": 320
  }
}

Validation Steps (Deterministic):
1. Schema Check:
   - sku exists? ‚úÖ
   - price >= 0? ‚úÖ
2. Business Rule:
   - Old price = 299.99
   - Deviation = ~6.6% ‚Üí within threshold
3. Risk Check:
   - No PRICE_OUTLIER

Output:
{
  "valid": true,
  "riskFlag": null,
  "errors": [],
  "entityExists": true,
  "businessRulesPassed": true,
  "requiresConfirmation": false,
  "timestamp": "2026-01-29T10:11:00.120Z",
  "traceId": "t-101",
  "workflowId": "SHOP-7788"
}

üìå Debug Tips:
- Validation failing unexpectedly?
  - Check price.guard.ts
  - Check validation.guard.ts
- Wrong threshold?
  - Metrics will show guardrail_triggers

Cell 4 ‚Äî ExecutionAgent (NO LLM):
Input:
{
  "intent": "UPDATE_PRODUCT_PRICE",
  "entities": {
    "sku": "HP-BLK-001",
    "newPrice": 320
  },
  "confirmed": true
}

Execution Steps:
1. Map intent ‚Üí API endpoint:
   PUT /api/v1/products/HP-BLK-001/price
2. Call Backend API
3. Backend updates products.json
4. Atomic write succeeds

Output:
{
  "success": true,
  "data": {
    "sku": "HP-BLK-001",
    "oldPrice": 299.99,
    "newPrice": 320,
    "productName": "Premium Wireless Headphones",
    "updatedAt": "2026-01-29T10:11:00.280Z"
  },
  "error": null,
  "apiResponse": {
    "statusCode": 200,
    "message": "Product price updated successfully"
  },
  "timestamp": "2026-01-29T10:11:00.280Z",
  "traceId": "t-101",
  "workflowId": "SHOP-7788"
}

üìå Debug Tips:
- API error?
  - Check /routes/products.ts
  - Check API metrics (status_code)
- Data not updated?
  - Inspect storage.ts

Cell 5 ‚Äî ExplanationAgent:
Input:
{
  "success": true,
  "intent": "UPDATE_PRODUCT_PRICE",
  "data": {
    "sku": "HP-BLK-001",
    "oldPrice": 299.99,
    "newPrice": 320
  }
}

Output:
"‚úÖ Successfully updated the price of Premium Wireless Headphones (HP-BLK-001) from $299.99 to $320."

üìå Debug Tips:
- Wrong message?
  - ExplanationAgent uses LLM for natural language generation
  - Easy to fix, no LLM risk

Cell 6 ‚Äî Workflow Completion:
Workflow State:
{
  "status": "COMPLETED",
  "workflowId": "SHOP-7788",
  "traceId": "t-101",
  "sessionId": "sess-abc123",
  "updatedAt": "2026-01-29T10:11:00.340Z"
}

Final Metrics:
{
  "total_latency_ms": 340,
  "agent_steps": 4,
  "success": true,
  "workflowTimestampStart": "2026-01-29T10:11:00.000Z",
  "workflowTimestampEnd": "2026-01-29T10:11:00.340Z"
}


Scenario 2: Price Outlier ‚Üí Human-in-the-Loop

User Input:
"Change price of PD-1067 to $67"

PlannerAgent:
Output:
{
  "intent": "UPDATE_PRODUCT_PRICE",
  "entities": {
    "sku": "PD-1067",
    "newPrice": 67
  },
  "confidence": 0.96,
  "timestamp": "2026-01-29T10:11:00.045Z",
  "traceId": "t-101",
  "workflowId": "SHOP-7788"
}

ValidationAgent (Key Difference):
Old price = 890
New price = 67
Deviation = 92%

Output:
{
  "valid": false,
  "riskFlag": "PRICE_OUTLIER",
  "errors": ["Price deviation 92% exceeds 40% threshold"],
  "entityExists": true,
  "businessRulesPassed": false,
  "oldPrice": 890,
  "newPrice": 67,
  "deviationPercent": 92.47,
  "requiresConfirmation": true,
  "timestamp": "2026-01-29T10:11:00.120Z",
  "traceId": "t-101",
  "workflowId": "SHOP-7788"
}

Workflow Decision:
üö´ STOP execution

Workflow State Saved:
{
  "status": "PENDING_CONFIRMATION",
  "workflowId": "SHOP-7788",
  "traceId": "t-101",
  "sessionId": "sess-abc123",
  "pendingAction": {
    "intent": "UPDATE_PRODUCT_PRICE",
    "entity": {
      "sku": "PD-1067",
      "newPrice": 67
    },
    "riskFlag": "PRICE_OUTLIER",
    "originalValue": 890,
    "requestedValue": 67
  },
  "updatedAt": "2026-01-29T10:11:00.120Z"
}

Response to User:
"‚ö†Ô∏è This is a large price change (from $890 ‚Üí $67, 92% drop).

Please confirm:
'CONFIRM price change for PD-1067 to $67'"

üìå Debug Tips:
- Check /state/workflow_state.json
- Confirm pendingConfirmation = true
- Metrics show guardrail_triggers: ["PRICE_OUTLIER"]

User Confirms:
"CONFIRM price change for PD-1067 to $67"

What Happens:
- Planner detects CONFIRM intent
- Workflow loads saved state
- Skips validation (already validated)
- Executes update
- Completes workflow

üìå Important:
‚úî No Loop Agent
‚úî No HumanAgent
‚úî Just state + resume


Scenario 3: SKU Not Found (Fast Fail)

User Input:
"Change price of SKU-9999 to $50"

PlannerAgent:
Output:
{
  "intent": "UPDATE_PRODUCT_PRICE",
  "entities": {
    "sku": "SKU-9999",
    "newPrice": 50
  },
  "confidence": 0.92,
  "timestamp": "2026-01-29T10:11:00.045Z",
  "traceId": "t-101",
  "workflowId": "SHOP-7788"
}

ValidationAgent Output:
{
  "valid": false,
  "riskFlag": "SKU_NOT_FOUND",
  "errors": ["Product with SKU SKU-9999 not found"],
  "entityExists": false,
  "businessRulesPassed": false,
  "requiresConfirmation": false,
  "timestamp": "2026-01-29T10:11:00.120Z",
  "traceId": "t-101",
  "workflowId": "SHOP-7788"
}

Response:
"‚ùå Error: Product SKU-9999 not found. Please check the SKU and try again."

Workflow State:
{
  "status": "FAILED",
  "workflowId": "SHOP-7788",
  "traceId": "t-101",
  "sessionId": "sess-abc123",
  "updatedAt": "2026-01-29T10:11:00.120Z"
}

Workflow ends immediately.

üìå Debug:
- ValidationAgent metrics
- No ExecutionAgent call
- agent_steps = 2


How You Debug This Like a Notebook:

When something breaks, you ask in this order:

1. Did Planner understand intent?
   - Check intent_confidence
   - Check /prompts/planner.v2.txt
   - Check LLM metrics

2. Did Validation block it?
   - Check riskFlag, errors
   - Check /tools/validation.guard.ts
   - Check /tools/price.guard.ts

3. Was HITL triggered?
   - Check workflow state (/state/workflow_state.json)
   - Check status: PENDING_CONFIRMATION
   - Check pendingAction

4. Did API fail?
   - Check API metrics (status_code)
   - Check /routes/products.ts
   - Check storage.ts

5. Did response look wrong?
   - ExplanationAgent (uses LLM for explanations)
   - Check response templates

You never guess.
Everything is traceable.

Interview-Ready One-Liner:
"We debug agent workflows the same way we debug distributed systems ‚Äî tracing intent extraction, validation decisions, tool calls, and state transitions with deterministic checkpoints and metrics at each step."


==================================================
27. Development Phase Checklist:
==================================================
Phase 1 ‚Äì Infrastructure:
‚úÖ Agent service skeleton
‚úÖ State store module
‚úÖ Metrics logger
‚úÖ Trace ID middleware

Phase 2 ‚Äì Agent Core:
‚úÖ Planner prompt
‚úÖ Validation rules
‚úÖ Guardrail logic
‚úÖ Tool registry

Phase 3 ‚Äì Human Loop:
‚úÖ Pending state persistence
‚úÖ Confirmation detection
‚úÖ Resume execution

Phase 4 ‚Äì Observability:
‚úÖ Metrics append
‚úÖ Trace logs
‚úÖ Error logs

Phase 5 ‚Äì Tests:
‚úÖ Guardrail tests
‚úÖ Confirmation tests
‚úÖ API tests


==================================================
28. ADK Agent Architecture - When to Use LlmAgent:
==================================================
Key Principle:
‚úÖ Only LlmAgent can reliably produce structured output from natural language
‚ùå WorkflowAgent, ValidationAgent, ExecutionAgent cannot parse free-form text or infer intent

Rule:
Natural language ‚Üí structured JSON = LlmAgent

==================================================
29. The CORRECT ADK Pattern (Enterprise-Grade):
==================================================
‚ùå Wrong Pattern (Common Mistake):
"Use LlmAgent everywhere because it can do reasoning"

Problems:
- Non-determinism
- Hard debugging
- Dangerous tool calls
- Interview red flags

‚úÖ Correct ADK Pattern (Strong Teams):
Use ONE LlmAgent as boundary translator, then everything else is deterministic.

Flow:
Natural Language
   ‚Üì
[LlmAgent]  ‚Üê structured output (JSON)
   ‚Üì
[WorkflowAgent]
   ‚Üì
Validation (TypeScript - deterministic)
   ‚Üì
Execution (Tools - deterministic)
   ‚Üì
Response (Template or optional LlmAgent)

This aligns perfectly with ADK's philosophy.

==================================================
30. System Mapped to ADK Components:
==================================================
Agent 1: PlannerAgent (LlmAgent) ‚úÖ

Purpose:
Convert admin English ‚Üí structured command

This is where structured output schemas matter.

ADK Implementation (TypeScript, ADK v0.2+):
```typescript
import { LlmAgent } from "@google/adk";
import { Schema, Type } from "@google/genai";

const PlannerOutputSchema: Schema = {
  type: Type.OBJECT,
  properties: {
    intent: { type: Type.STRING },
    entities: { type: Type.OBJECT },
    confidence: { type: Type.NUMBER }
  },
  required: ["intent", "entities", "confidence"]
};

export const PlannerAgent = new LlmAgent({
  name: "planner_agent",
  model: "qwen3-coder:30b",
  instruction: `
You are an admin command parser.

Extract intent and entities.
Respond ONLY in JSON matching the schema.
`,
  outputSchema: PlannerOutputSchema,
  outputKey: "plan"
});
```

Why This is Correct:
- Structured output enforced
- Stored in workflow state
- Easy to debug (state.plan)
- No tools here ‚Üí safer

Agent 2: WorkflowAgent (NO LLM) ‚ùåüß†

Purpose:
Orchestrate steps, not think.

Implementation:
```typescript
export const AdminWorkflow = new WorkflowAgent({
  name: "admin_workflow",
  run: async (ctx) => {
    const plan = ctx.state.plan; // from PlannerAgent
    // deterministic routing
  }
});
```

Why No LLM:
- Execution order must be predictable
- Notebook-style tracing required
- ADK explicitly designed WorkflowAgent for this

Agent 3: ValidationAgent (NO LLM) ‚ùåüß†

Purpose:
Guardrails, thresholds, HITL decisions

Implementation:
```typescript
if (priceChange > 0.5) {
  ctx.state.pendingConfirmation = true;
}
```

Why No LLM:
- Business rules ‚â† language reasoning
- Deterministic
- Testable

Agent 4: ExecutionAgent (Tools, NO LLM) ‚ùåüß†

Purpose:
Call backend APIs

Implementation:
```typescript
tools: [updatePriceTool]
```

Critical ADK Rule:
LLMs decide WHAT, tools do HOW

Agent 5: ExplanationAgent (Uses LLM)

Options:
- Deterministic text (recommended for safety)
- OR tiny LlmAgent for UX polish (optional)

==================================================
31. BuiltInPlanner / PlanReActPlanner - Should You Use?
==================================================
Answer: NO

Why:
- You already separated planning (PlannerAgent)
- You want predictable admin actions
- PlanReAct adds reasoning noise

Interview-Safe Explanation:
"We avoid multi-step LLM planning for admin mutations and instead use a single structured intent extraction step followed by deterministic workflows."

This is a strong answer.

==================================================
32. Human-in-the-Loop (ADK Implementation):
==================================================
You do NOT need:
- HumanAgent
- LoopAgent

You already do HITL via state + confirmation intent.

Flow:
PRICE_OUTLIER
   ‚Üì
state.pendingAction
   ‚Üì
CONFIRM intent (detected by PlannerAgent)
   ‚Üì
resume workflow (WorkflowAgent)

This is clean ADK usage.

==================================================
33. ADK Component Decision Table:
==================================================
| Component         | ADK Type        | LLM? | Why                          |
| ----------------- | --------------- | ---- | ---------------------------- |
| Intent extraction | LlmAgent        | ‚úÖ    | Language ‚Üí JSON              |
| Structured output | outputSchema    | ‚úÖ    | Enforced format              |
| Orchestration     | WorkflowAgent   | ‚ùå    | Deterministic                |
| Validation        | TS functions    | ‚ùå    | Guardrails                   |
| API calls         | Tools           | ‚ùå    | Safety                       |
| HITL              | State           | ‚ùå    | Resume safely                |
| Response          | Template/LlmAgent | ‚ùå/‚úÖ | Optional for UX polish      |

Key Principle:
- LLM only where understanding language or reasoning about unstructured input is required
- Deterministic, safety-critical, or action-oriented steps never use LLM

==================================================
34. Interview-Ready One-Liner (ADK Architecture):
==================================================
"In ADK we use an LlmAgent strictly as a language-to-structure boundary with enforced output schemas, and then hand off to WorkflowAgents and tools for deterministic execution, guardrails, and human-in-the-loop control."

This demonstrates:
- Clear understanding of ADK components
- Enterprise-grade safety thinking
- Proper separation of concerns
- Interview-ready explanation

==================================================
35. Structured Output Schema (PlannerAgent):
==================================================
PlannerAgent Output Schema:
```typescript
{
  type: Type.OBJECT,
  properties: {
    intent: { 
      type: Type.STRING,
      enum: [
        "UPDATE_PRODUCT_PRICE",
        "UPDATE_PRODUCT_DESCRIPTION",
        "CANCEL_ORDER",
        "UPDATE_ORDER_STATUS",
        "SHOW_PRODUCT_INFO",
        "SHOW_ORDER_INFO",
        "UPDATE_PROMOTION_STATUS",
        "GET_INVENTORY_LEVEL"
      ]
    },
    entities: { 
      type: Type.OBJECT,
      properties: {
        sku: { type: Type.STRING, optional: true },
        orderNumber: { type: Type.STRING, optional: true },
        newPrice: { type: Type.NUMBER, optional: true },
        status: { type: Type.STRING, optional: true },
        // ... other entity fields
      }
    },
    confidence: { 
      type: Type.NUMBER,
      minimum: 0,
      maximum: 1
    }
  },
  required: ["intent", "entities", "confidence"]
}
```

Benefits:
- Type-safe parsing
- Validation at LLM boundary
- Easy debugging
- No schema drift

==================================================
36. ADK Agent Flow (Complete):
==================================================
User Input (Natural Language)
   ‚Üì
[PlannerAgent - LlmAgent]
   - Uses outputSchema
   - Stores in state.plan
   - Returns: {intent, entities, confidence}
   ‚Üì
[WorkflowAgent]
   - Reads state.plan
   - Routes to ValidationAgent
   ‚Üì
[ValidationAgent - TypeScript Functions]
   - Checks guardrails
   - Calculates risk flags
   - Sets state.pendingConfirmation if needed
   ‚Üì
Decision Point:
   ‚îú‚îÄ‚îÄ HITL Required? ‚Üí Save state, ask user
   ‚îî‚îÄ‚îÄ Proceed? ‚Üí Continue to ExecutionAgent
   ‚Üì
[ExecutionAgent - Tools]
   - Calls backend API
   - Updates data
   - Returns success/error
   ‚Üì
[ExplanationAgent - LlmAgent]
   - Generates natural language explanation after actions
   - OR answers questions about session history
   - Uses LLM to understand context and provide responses
   - Returns to UI

Key Points:
- PlannerAgent uses LLM (required for intent extraction)
- ExplanationAgent uses LLM (for natural language explanations and session history questions)
- Everything else is deterministic
- State flows through WorkflowAgent
- Tools execute actions safely
- ExplanationAgent can answer questions about what happened in the session

==================================================
37. Why This Architecture is Interview-Ready:
==================================================
Demonstrates:
1. Clear understanding of ADK components
   - Knows when to use LlmAgent vs WorkflowAgent
   - Understands structured output schemas
   - Proper tool usage

2. Enterprise-grade safety thinking
   - LLM only at language boundary
   - Deterministic validation and execution
   - Guardrails and HITL properly implemented

3. Proper separation of concerns
- Planner extracts intent (LLM)
- Validator enforces rules (deterministic)
- Executor performs actions (tools)
- Explainer generates natural language (LLM)

4. Interview-ready explanation
   - Can articulate design decisions
   - Understands trade-offs
   - Follows ADK best practices

This architecture is production-ready and demonstrates strong engineering judgment.


==================================================
38. Happy Path Walkthrough - End-to-End Example:
==================================================
Use Case:
Admin types: "Change the price of SKU-001 to $49.99"

This walkthrough shows:
- What runs at each step
- Who uses the LLM
- What data looks like at each step
- Why this is correct ADK usage

No edge cases, no HITL, no retries - just the clean happy path.

==================================================
39. Step 0: Initial State:
==================================================
Admin is on /admin
Chatbot UI sends raw text to agent service

Request Payload:
```json
{
  "message": "Change the price of SKU-001 to $49.99",
  "sessionId": "sess-abc123"
}
```

System generates:
- traceId: "t-101"
- workflowId: "SHOP-7788"
- workflowTimestampStart: "2026-01-29T10:11:00.000Z"

==================================================
40. Step 1: PlannerAgent (LlmAgent) ‚úÖ - ONLY LLM Usage:
==================================================
Why This Agent Exists:
Natural language ‚Üí structured command
This is NOT executable yet, just interpretation.

Input to LLM:
```
Change the price of SKU-001 to $49.99
```

PlannerAgent Instruction (from prompt registry):
```
You are an admin command parser.
Extract intent and entities.
Return JSON only.
```

LLM Output (schema-validated):
```json
{
  "intent": "UPDATE_PRODUCT_PRICE",
  "entities": {
    "sku": "SKU-001",
    "newPrice": 49.99
  },
  "confidence": 0.96
}
```

What ADK Does:
- Validates against outputSchema
- Stores result in workflow state:
  ```typescript
  ctx.state.plan = {
    intent: "UPDATE_PRODUCT_PRICE",
    entities: { sku: "SKU-001", newPrice: 49.99 },
    confidence: 0.96
  }
  ```

üö´ No API calls
üö´ No side effects
üö´ No branching

Metrics Logged:
```json
{
  "layer": "PLANNER_AGENT",
  "timestamp": "2026-01-29T10:11:00.045Z",
  "metrics": {
    "plannerAgent": {
      "timestampStart": "2026-01-29T10:11:00.000Z",
      "timestampCompleted": "2026-01-29T10:11:00.045Z",
      "latency_ms": 45,
      "intent": "UPDATE_PRODUCT_PRICE",
      "intent_confidence": 0.96,
      "entities_extracted": 2,
      "llm_calls": 1,
      "errors": 0
    },
    "llm": {
      "prompt_tokens": 412,
      "completion_tokens": 91,
      "total_tokens": 503,
      "context_usage_pct": 32,
      "latency_ms": 40,
      "retry_count": 0,
      "model": "qwen3-coder:30b"
    }
  }
}
```

==================================================
41. Step 2: WorkflowAgent (NO LLM) ‚ùåüß† - Deterministic Routing:
==================================================
Why No LLM Here:
- We already understand the command
- Now we EXECUTE, not reason

WorkflowAgent Logic:
```typescript
const plan = ctx.state.plan;

switch (plan.intent) {
  case "UPDATE_PRODUCT_PRICE":
    // Route to validation step
    return await ctx.run("validate_price_update", {
      sku: plan.entities.sku,
      newPrice: plan.entities.newPrice
    });
  // ... other cases
}
```

üìå Think of this as a CONTROLLER, not a thinker.

State After Routing:
```typescript
ctx.state.currentStep = "VALIDATION"
ctx.state.validationInput = {
  sku: "SKU-001",
  newPrice: 49.99
}
```

==================================================
42. Step 3: Validation Step (NO LLM) ‚ùåüß†:
==================================================
What Happens:
Simple business checks - deterministic TypeScript functions.

Validation Logic:
```typescript
// Check 1: SKU exists
const product = await getProductBySku("SKU-001");
if (!product) {
  throw new Error("SKU_NOT_FOUND");
}

// Check 2: Price is non-negative
if (49.99 < 0) {
  throw new Error("INVALID_PRICE");
}

// Check 3: Price deviation (if applicable)
const oldPrice = product.price;
const deviation = Math.abs(49.99 - oldPrice) / oldPrice;
if (deviation > 0.40) {
  // Would trigger HITL, but this is happy path
  // deviation is small, so continue
}

// All checks pass
return {
  valid: true,
  riskFlag: null,
  errors: []
};
```

Happy Path ‚Üí Validation Passes

Output:
```json
{
  "valid": true,
  "riskFlag": null,
  "errors": [],
  "entityExists": true,
  "businessRulesPassed": true,
  "requiresConfirmation": false,
  "timestamp": "2026-01-29T10:11:00.120Z",
  "traceId": "t-101",
  "workflowId": "SHOP-7788"
}
```

üìå This is:
- Testable
- Predictable
- Interview-safe

Metrics Logged:
```json
{
  "layer": "VALIDATION_AGENT",
  "timestamp": "2026-01-29T10:11:00.120Z",
  "metrics": {
    "validationAgent": {
      "timestampStart": "2026-01-29T10:11:00.045Z",
      "timestampCompleted": "2026-01-29T10:11:00.120Z",
      "latency_ms": 75,
      "schema_validation_failures": 0,
      "guardrail_triggers": [],
      "risk_flags": [],
      "validation_passed": true,
      "errors": 0
    }
  }
}
```

==================================================
43. Step 4: Execution Tool (NO LLM) ‚ùåüß†:
==================================================
Tool Definition:
```typescript
export const updatePriceTool = new FunctionTool({
  name: "update_product_price",
  description: "Update product price via backend API",
  parameters: z.object({
    sku: z.string().describe("Product SKU"),
    price: z.number().describe("New price")
  }),
  execute: async ({ sku, price }) => {
    const response = await fetch(`http://localhost:5000/api/v1/products/${sku}/price`, {
      method: "PUT",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ price })
    });
    
    if (!response.ok) {
      throw new Error(`API error: ${response.statusText}`);
    }
    
    return await response.json();
  }
});
```

WorkflowAgent Calls Tool:
```typescript
const result = await ctx.tools.update_product_price({
  sku: "SKU-001",
  price: 49.99
});
```

Tool Execution:
1. Calls backend API: PUT /api/v1/products/SKU-001/price
2. Backend updates products.json
3. Returns success response

Tool Response:
```json
{
  "success": true,
  "data": {
    "sku": "SKU-001",
    "oldPrice": 39.99,
    "newPrice": 49.99,
    "productName": "Sample Product",
    "updatedAt": "2026-01-29T10:11:00.280Z"
  }
}
```

üìå Important:
- LLM does NOT touch APIs
- Tools are pure execution
- Deterministic and safe

Metrics Logged:
```json
{
  "layer": "EXECUTION_AGENT",
  "timestamp": "2026-01-29T10:11:00.280Z",
  "metrics": {
    "executionAgent": {
      "timestampStart": "2026-01-29T10:11:00.120Z",
      "timestampCompleted": "2026-01-29T10:11:00.280Z",
      "latency_ms": 160,
      "tool_calls": 1,
      "api_calls": 1,
      "api_success": true,
      "data_updated": true,
      "errors": 0
    },
    "api": {
      "api_latency_ms": 41,
      "file_write_ms": 12,
      "endpoint": "/api/v1/products/SKU-001/price",
      "method": "PUT",
      "status_code": 200,
      "errors": 0
    }
  }
}
```

==================================================
44. Step 5: Explanation Generation (Uses LLM):
==================================================
ExplanationAgent Logic (Uses LLM):
```typescript
// ExplanationAgent uses LLM to generate natural language explanations
const explanation = await llmAgent.generate({
  instruction: explanationPrompt,
  context: {
    success: data.success,
    intent: data.intent,
    data: data.data,
    error: data.error
  }
});
```

Response:
```json
{
  "message": "‚úÖ Successfully updated the price of Sample Product (SKU-001) from $39.99 to $49.99.",
  "traceId": "t-101",
  "workflowId": "SHOP-7788",
  "timestamp": "2026-01-29T10:11:00.340Z"
}
```

Sent back to chatbot UI.

Metrics Logged:
```json
{
  "layer": "EXPLANATION_AGENT",
  "timestamp": "2026-01-29T10:11:00.340Z",
  "metrics": {
    "responseAgent": {
      "timestampStart": "2026-01-29T10:11:00.280Z",
      "timestampCompleted": "2026-01-29T10:11:00.340Z",
      "latency_ms": 60,
      "response_type": "success",
      "message_length": 87,
      "errors": 0
    }
  }
}
```

==================================================
45. Step 6: Workflow Completion:
==================================================
Final Workflow State:
```json
{
  "status": "COMPLETED",
  "workflowId": "SHOP-7788",
  "traceId": "t-101",
  "sessionId": "sess-abc123",
  "workflowTimestampStart": "2026-01-29T10:11:00.000Z",
  "workflowTimestampEnd": "2026-01-29T10:11:00.340Z",
  "updatedAt": "2026-01-29T10:11:00.340Z"
}
```

Final Metrics:
```json
{
  "layer": "WORKFLOW",
  "timestamp": "2026-01-29T10:11:00.340Z",
  "metrics": {
    "workflow": {
      "workflow_id": "SHOP-7788",
      "trace_id": "t-101",
      "total_latency_ms": 340,
      "success": true,
      "retries": 0,
      "agent_steps": 4,
      "workflowTimestampStart": "2026-01-29T10:11:00.000Z",
      "workflowTimestampEnd": "2026-01-29T10:11:00.340Z"
    }
  }
}
```

==================================================
46. Full Happy-Path Flow (Visual):
==================================================
```
Admin text: "Change the price of SKU-001 to $49.99"
   ‚Üì
[PlannerAgent - LlmAgent] ‚úÖ LLM USED HERE
   - Input: Natural language
   - Output: {intent, entities, confidence}
   - Stored in: ctx.state.plan
   ‚Üì
[WorkflowAgent] ‚ùå NO LLM
   - Reads: ctx.state.plan
   - Routes: Based on intent
   ‚Üì
[ValidationAgent] ‚ùå NO LLM
   - Checks: Business rules
   - Output: {valid: true}
   ‚Üì
[ExecutionAgent - Tool] ‚ùå NO LLM
   - Calls: Backend API
   - Updates: products.json
   ‚Üì
[ExplanationAgent] ‚úÖ Uses LLM (natural language generation)
   - Formats: Success message
   ‚Üì
Success message to UI
```

Key Points:
- LLM used ONLY at language boundary (PlannerAgent)
- Everything else is deterministic
- Clear separation of concerns
- Easy to debug and trace

==================================================
47. What We Intentionally DID NOT Use (And Why):
==================================================
| Thing                 | Why Not Used                    |
| --------------------- | ------------------------------- |
| Multi-agent reasoning | Overkill for simple commands    |
| PlanReAct             | Non-deterministic, adds noise    |
| LLM validation        | Risky, unpredictable            |
| Human-in-loop         | Not needed (happy path)          |
| Confidence threshold  | Happy path, high confidence      |
| LLM for execution     | Dangerous, tools are safer      |
| LLM for response      | Optional, template is safer      |

This demonstrates:
- Clear understanding of when NOT to use LLM
- Safety-first approach
- Production-ready thinking

==================================================
48. Interview-Ready Explanation (One Clean Sentence):
==================================================
"We use the LLM only to translate natural language into a structured intent; all validation, orchestration, and API execution are deterministic and handled without an LLM."

This is the money line üí∞

Why This Works:
- Shows clear understanding of ADK architecture
- Demonstrates safety thinking
- Explains separation of concerns
- Production-ready approach

Alternative Explanation:
"In ADK, we use an LlmAgent strictly as a language-to-structure boundary with enforced output schemas, then hand off to WorkflowAgents and tools for deterministic execution, guardrails, and control."

Both explanations demonstrate:
- Clear architecture understanding
- Enterprise-grade safety
- Proper ADK usage
- Interview-ready communication

==================================================
49. Data Flow Summary (Happy Path):
==================================================
Input:
```json
{
  "message": "Change the price of SKU-001 to $49.99"
}
```

After PlannerAgent (LLM):
```json
{
  "intent": "UPDATE_PRODUCT_PRICE",
  "entities": { "sku": "SKU-001", "newPrice": 49.99 },
  "confidence": 0.96
}
```

After Validation:
```json
{
  "valid": true,
  "riskFlag": null,
  "errors": []
}
```

After Execution:
```json
{
  "success": true,
  "data": {
    "sku": "SKU-001",
    "oldPrice": 39.99,
    "newPrice": 49.99
  }
}
```

Final Response:
```json
{
  "message": "‚úÖ Successfully updated the price of Sample Product (SKU-001) from $39.99 to $49.99."
}
```

Key Insight:
Data transforms from unstructured (natural language) to structured (JSON) at the LLM boundary, then flows deterministically through the rest of the system.

==================================================
50. Why This Architecture is Production-Correct:
==================================================
1. Clear LLM Boundary:
   - LLM used ONLY where needed (language understanding)
   - Everything else is deterministic

2. Safety First:
   - Validation before execution
   - Tools handle API calls safely
   - No LLM in critical paths

3. Traceability:
   - Every step logged with metrics
   - State transitions are clear
   - Easy to debug

4. Testability:
   - Each component can be tested independently
   - Deterministic steps are easy to verify
   - LLM output can be mocked

5. Scalability:
   - LLM calls are minimal (only at boundary)
   - Deterministic steps are fast
   - Clear separation allows optimization

This architecture is production-ready and demonstrates strong engineering judgment.


==================================================
51. Universal JSON Schema - System-Wide State:
==================================================
This is a robust universal JSON schema that flows through your entire agent system.
It provides a single source of truth for all agent state, metrics, and traceability.

Complete Schema Structure:
```json
{
  "universalState": {
    "inputSchema": {
      "message": "string - original user input",
      "sessionId": "string - browser session",
      "traceId": "string - unique trace ID",
      "workflowId": "string - workflow identifier",
      "timestamp": "ISO datetime - when request started"
    },
    "metrics": {
      "workflowTimestampStart": "ISO datetime",
      "workflowTimestampEnd": "ISO datetime | null",
      "totalLatencyMs": "number | null",
      "agentSteps": "number",
      "success": "boolean | null",
      "retries": "number",
      
      "plannerAgent": {
        "timestampStart": "ISO datetime | null",
        "timestampCompleted": "ISO datetime | null",
        "latencyMs": "number | null",
        "intent": "string | null",
        "intentConfidence": "number | null",
        "entitiesExtracted": "number | null",
        "llmCalls": "number",
        "errors": "number"
      },
      
      "validationAgent": {
        "timestampStart": "ISO datetime | null",
        "timestampCompleted": "ISO datetime | null",
        "latencyMs": "number | null",
        "schemaValidationFailures": "number",
        "guardrailTriggers": "string[]",
        "riskFlags": "string[]",
        "validationPassed": "boolean | null",
        "errors": "number"
      },
      
      "executionAgent": {
        "timestampStart": "ISO datetime | null",
        "timestampCompleted": "ISO datetime | null",
        "latencyMs": "number | null",
        "toolCalls": "number",
        "apiCalls": "number",
        "apiSuccess": "boolean | null",
        "dataUpdated": "boolean | null",
        "errors": "number"
      },
      
      "responseAgent": {
        "timestampStart": "ISO datetime | null",
        "timestampCompleted": "ISO datetime | null",
        "latencyMs": "number | null",
        "responseType": "success | confirmation | error | null",
        "messageLength": "number | null",
        "errors": "number"
      },
      
      "llm": {
        "promptTokens": "number",
        "completionTokens": "number",
        "totalTokens": "number",
        "contextUsagePct": "number",
        "latencyMs": "number | null",
        "retryCount": "number",
        "model": "string"
      },
      
      "api": {
        "apiLatencyMs": "number | null",
        "fileWriteMs": "number | null",
        "endpoint": "string | null",
        "method": "string | null",
        "statusCode": "number | null",
        "errors": "number"
      }
    },
    
    "state": {
      "currentStep": "IDLE | PLANNING | VALIDATING | EXECUTING | RESPONDING | COMPLETED | FAILED",
      "workflowStatus": "IDLE | PENDING_CONFIRMATION | EXECUTING | COMPLETED | FAILED",
      
      "plan": {
        "intent": "string | null",
        "entities": "object | null",
        "confidence": "number | null"
      },
      
      "validation": {
        "valid": "boolean | null",
        "riskFlag": "string | null",
        "errors": "string[]",
        "entityExists": "boolean | null",
        "businessRulesPassed": "boolean | null",
        "requiresConfirmation": "boolean",
        "oldValue": "any | null",
        "newValue": "any | null",
        "deviationPercent": "number | null"
      },
      
      "execution": {
        "success": "boolean | null",
        "data": "object | null",
        "error": "string | null",
        "apiResponse": "object | null"
      },
      
      "response": {
        "message": "string | null",
        "responseType": "success | confirmation | error | null"
      },
      
      "pendingAction": {
        "intent": "string | null",
        "entity": "object | null",
        "riskFlag": "string | null",
        "originalValue": "any | null",
        "requestedValue": "any | null"
      },
      
      "conversationSummary": "string | null"
    }
  }
}
```

==================================================
52. How Each Agent Uses This Schema:
==================================================
PlannerAgent Fills:
```typescript
universalState.state.plan = {
  intent: "UPDATE_PRODUCT_PRICE",
  entities: { sku: "SKU-001", newPrice: 49.99 },
  confidence: 0.96
};

universalState.metrics.plannerAgent = {
  timestampStart: "2026-01-29T10:11:00.000Z",
  timestampCompleted: "2026-01-29T10:11:00.045Z",
  latencyMs: 45,
  intent: "UPDATE_PRODUCT_PRICE",
  intentConfidence: 0.96,
  entitiesExtracted: 2,
  llmCalls: 1,
  errors: 0
};

universalState.state.currentStep = "PLANNING";
```

ValidationAgent Fills:
```typescript
universalState.state.validation = {
  valid: true,
  riskFlag: null,
  errors: [],
  entityExists: true,
  businessRulesPassed: true,
  requiresConfirmation: false,
  oldValue: 39.99,
  newValue: 49.99,
  deviationPercent: 25.0
};

universalState.metrics.validationAgent = {
  timestampStart: "2026-01-29T10:11:00.045Z",
  timestampCompleted: "2026-01-29T10:11:00.120Z",
  latencyMs: 75,
  schemaValidationFailures: 0,
  guardrailTriggers: [],
  riskFlags: [],
  validationPassed: true,
  errors: 0
};

universalState.state.currentStep = "VALIDATING";
```

ExecutionAgent Fills:
```typescript
universalState.state.execution = {
  success: true,
  data: {
    sku: "SKU-001",
    oldPrice: 39.99,
    newPrice: 49.99,
    productName: "Sample Product",
    updatedAt: "2026-01-29T10:11:00.280Z"
  },
  error: null,
  apiResponse: {
    statusCode: 200,
    message: "Product price updated successfully"
  }
};

universalState.metrics.executionAgent = {
  timestampStart: "2026-01-29T10:11:00.120Z",
  timestampCompleted: "2026-01-29T10:11:00.280Z",
  latencyMs: 160,
  toolCalls: 1,
  apiCalls: 1,
  apiSuccess: true,
  dataUpdated: true,
  errors: 0
};

universalState.metrics.api = {
  apiLatencyMs: 41,
  fileWriteMs: 12,
  endpoint: "/api/v1/products/SKU-001/price",
  method: "PUT",
  statusCode: 200,
  errors: 0
};

universalState.state.currentStep = "EXECUTING";
```

ExplanationAgent Fills:
```typescript
universalState.state.response = {
  message: "‚úÖ Successfully updated the price of Sample Product (SKU-001) from $39.99 to $49.99.",
  responseType: "success"
};

universalState.metrics.responseAgent = {
  timestampStart: "2026-01-29T10:11:00.280Z",
  timestampCompleted: "2026-01-29T10:11:00.340Z",
  latencyMs: 60,
  responseType: "success",
  messageLength: 87,
  errors: 0
};

universalState.state.currentStep = "RESPONDING";
universalState.state.workflowStatus = "COMPLETED";
```

WorkflowAgent Updates:
```typescript
// At workflow start
universalState.metrics.workflowTimestampStart = "2026-01-29T10:11:00.000Z";
universalState.state.workflowStatus = "EXECUTING";
universalState.state.currentStep = "PLANNING";

// At workflow completion
universalState.metrics.workflowTimestampEnd = "2026-01-29T10:11:00.340Z";
universalState.metrics.totalLatencyMs = 340;
universalState.metrics.agentSteps = 4;
universalState.metrics.success = true;
universalState.state.workflowStatus = "COMPLETED";
universalState.state.currentStep = "COMPLETED";
```

HITL Scenario (Price Outlier):
```typescript
// When validation detects price outlier
universalState.state.validation = {
  valid: false,
  riskFlag: "PRICE_OUTLIER",
  errors: ["Price deviation 92% exceeds 40% threshold"],
  entityExists: true,
  businessRulesPassed: false,
  requiresConfirmation: true,
  oldValue: 890,
  newValue: 67,
  deviationPercent: 92.47
};

universalState.state.pendingAction = {
  intent: "UPDATE_PRODUCT_PRICE",
  entity: { sku: "PD-1067", newPrice: 67 },
  riskFlag: "PRICE_OUTLIER",
  originalValue: 890,
  requestedValue: 67
};

universalState.state.workflowStatus = "PENDING_CONFIRMATION";
universalState.state.currentStep = "VALIDATING";
```

==================================================
53. Key Benefits of Universal Schema:
==================================================
1. Single Source of Truth:
   - Every agent reads/writes to the same schema
   - No data duplication
   - Consistent state across all agents

2. Complete Traceability:
   - All metrics and state in one place
   - Easy to reconstruct workflow execution
   - Full audit trail

3. Easy Debugging:
   - Check universalState.state.currentStep to see where you are
   - Inspect any agent's output at any point
   - Notebook-style debugging tool

4. Metrics Ready:
   - All timing/performance data captured automatically
   - Per-agent metrics tracked
   - Workflow-level metrics aggregated

5. HITL Support:
   - pendingAction tracks confirmation workflows
   - workflowStatus shows PENDING_CONFIRMATION state
   - Easy to resume after confirmation

6. Type Safety:
   - Can be validated with TypeScript/Zod
   - Schema ensures data consistency
   - Prevents state corruption

7. Interview-Ready:
   - Demonstrates system design thinking
   - Shows understanding of state management
   - Production-grade architecture

==================================================
54. Schema Usage Pattern (TypeScript):
==================================================
Type Definition:
```typescript
interface UniversalState {
  inputSchema: {
    message: string;
    sessionId: string;
    traceId: string;
    workflowId: string;
    timestamp: string;
  };
  metrics: {
    workflowTimestampStart: string;
    workflowTimestampEnd: string | null;
    totalLatencyMs: number | null;
    agentSteps: number;
    success: boolean | null;
    retries: number;
    plannerAgent: AgentMetrics;
    validationAgent: AgentMetrics;
    executionAgent: AgentMetrics;
    explanationAgent: AgentMetrics;
    llm: LLMMetrics;
    api: APIMetrics;
  };
  state: {
    currentStep: WorkflowStep;
    workflowStatus: WorkflowStatus;
    plan: PlanState | null;
    validation: ValidationState | null;
    execution: ExecutionState | null;
    response: ResponseState | null;
    pendingAction: PendingAction | null;
    conversationSummary: string | null;
  };
}
```

Usage in WorkflowAgent:
```typescript
export const AdminWorkflow = new WorkflowAgent({
  name: "admin_workflow",
  run: async (ctx) => {
    // Initialize universal state
    const universalState: UniversalState = {
      inputSchema: {
        message: ctx.input.message,
        sessionId: ctx.session.id,
        traceId: ctx.traceId,
        workflowId: ctx.workflowId,
        timestamp: new Date().toISOString()
      },
      metrics: {
        workflowTimestampStart: new Date().toISOString(),
        workflowTimestampEnd: null,
        totalLatencyMs: null,
        agentSteps: 0,
        success: null,
        retries: 0,
        // ... initialize all metrics
      },
      state: {
        currentStep: "IDLE",
        workflowStatus: "IDLE",
        plan: null,
        validation: null,
        execution: null,
        response: null,
        pendingAction: null,
        conversationSummary: null
      }
    };

    // Store in workflow state
    ctx.state.universalState = universalState;

    // PlannerAgent updates universalState.state.plan
    // ValidationAgent updates universalState.state.validation
    // ExecutionAgent updates universalState.state.execution
    // ExplanationAgent updates universalState.state.response

    return universalState;
  }
});
```

Access Pattern:
```typescript
// In any agent
const universalState = ctx.state.universalState;

// Read previous agent's output
const plan = universalState.state.plan;

// Update current agent's state
universalState.state.validation = {
  valid: true,
  // ...
};

// Update metrics
universalState.metrics.validationAgent.timestampStart = new Date().toISOString();
```

==================================================
55. Schema as Notebook-Style Debugging Tool:
==================================================
This schema is your notebook-style debugging tool - you can inspect it at any point and see exactly what happened!

Example Debug Session:
```typescript
// At any breakpoint, inspect:
console.log("Current Step:", universalState.state.currentStep);
console.log("Workflow Status:", universalState.state.workflowStatus);
console.log("Plan:", universalState.state.plan);
console.log("Validation:", universalState.state.validation);
console.log("Execution:", universalState.state.execution);
console.log("Response:", universalState.state.response);

// Check metrics
console.log("Total Latency:", universalState.metrics.totalLatencyMs);
console.log("Planner Latency:", universalState.metrics.plannerAgent.latencyMs);
console.log("Validation Latency:", universalState.metrics.validationAgent.latencyMs);

// Check for errors
console.log("Planner Errors:", universalState.metrics.plannerAgent.errors);
console.log("Validation Errors:", universalState.metrics.validationAgent.errors);
console.log("Execution Errors:", universalState.metrics.executionAgent.errors);

// Check HITL state
if (universalState.state.workflowStatus === "PENDING_CONFIRMATION") {
  console.log("Pending Action:", universalState.state.pendingAction);
}
```

This allows you to:
- See exactly where the workflow is
- Inspect any agent's output
- Debug performance issues
- Trace errors
- Understand HITL state

All in one place! üéØ

==================================================
56. Schema Persistence Strategy:
==================================================
Where to Store:
- In-memory: During workflow execution (fast access)
- Workflow State: For multi-turn conversations
- JSON Snapshot: For debugging and audit (workflow.state.json)

Persistence Format:
```json
{
  "workflowId": "SHOP-7788",
  "traceId": "t-101",
  "sessionId": "sess-abc123",
  "universalState": {
    // ... full schema
  },
  "snapshotTimestamp": "2026-01-29T10:11:00.340Z"
}
```

Benefits:
- Can resume workflows from snapshot
- Full audit trail
- Easy to debug production issues
- Can replay workflows for testing

This universal schema is the backbone of your agent system - it ensures consistency, traceability, and debuggability throughout the entire workflow.


==================================================
57. ADK Pattern Selection - Correct Patterns for This System:
==================================================
This section locks the ADK pattern based on the system design (UniversalState, guardrails, HITL, deterministic execution).

Key Principle:
Everything designed earlier (UniversalState, guardrails, HITL, deterministic execution) already forces the answer.

==================================================
58. Primary Pattern - Sequential Pipeline Pattern (90% of System):
==================================================
Core Backbone: Sequential Pipeline Pattern (with Workflow Agent)

Why This is the Right Fit:
Your system is:
- Deterministic
- Step-driven
- Safety-first
- Auditable
- Debuggable
- Stateful
- Has clear checkpoints

That maps perfectly to:
```
SequentialAgent
  ‚îú‚îÄ‚îÄ PlannerAgent (LLM)
  ‚îú‚îÄ‚îÄ ValidationAgent (custom, no LLM)
  ‚îú‚îÄ‚îÄ ExecutionAgent (custom, no LLM)
  ‚îî‚îÄ‚îÄ ExplanationAgent (LlmAgent)
```

This matches Google's intended ADK usage for enterprise workflows.

ADK Implementation (Conceptual):
```typescript
const workflow = new SequentialAgent({
  name: "AdminWorkflow",
  subAgents: [
    plannerAgent,     // LLM
    validationAgent,  // deterministic
    executionAgent,   // deterministic
    explanationAgent  // uses LLM
  ]
});
```

Benefits:
‚úî Shared InvocationContext
‚úî Shared session.state
‚úî Linear, observable execution
‚úî Easy rollback / replay

==================================================
59. Mapping Your Design ‚Üí ADK Primitives:
==================================================
| Your Concept            | ADK Primitive            |
| ----------------------- | ------------------------ |
| UniversalState          | session.state             |
| Notebook-style steps    | SequentialAgent           |
| Intent extraction       | LlmAgent                 |
| Guardrails              | Custom BaseAgent          |
| HITL decision           | Policy / Validation gate |
| Deterministic execution | Custom agent              |
| Metrics                 | Callback + state          |
| Debug checkpoints       | State snapshots          |

This mapping ensures your design translates directly to ADK implementation.

==================================================
60. Secondary Pattern - Policy-Based Human-in-the-Loop (HITL):
==================================================
ONLY Pattern for Human-in-the-Loop: Policy-Based Human-in-the-Loop Pattern

Why NOT LoopAgent or "HumanAgent":
- LoopAgent = polling (wrong for admin UX)
- HumanAgent = not real in ADK
- Transfer-to-agent = overkill and unsafe

Correct Way (Google-Recommended):
‚úÖ SecurityPlugin + PolicyEngine

This integrates cleanly with:
- Guardrails
- Thresholds
- Confirmation UX
- Audit logs

HITL Pattern in Your System:

Trigger Condition (from ValidationAgent):
```typescript
requiresConfirmation === true
```

PolicyEngine Decision:
```typescript
return {
  outcome: PolicyOutcome.CONFIRM,
  reason: "Large price deviation"
};
```

Resulting Flow:
```
Planner
  ‚Üì
Validation (flags outlier)
  ‚Üì
PolicyEngine pauses tool
  ‚Üì
UI asks admin for confirmation
  ‚Üì
Admin confirms
  ‚Üì
Execution resumes
```

Benefits:
‚úî No loops
‚úî No fake agents
‚úî Fully auditable
‚úî Production-grade

==================================================
61. Patterns You Should NOT Use (And Why):
==================================================
‚ùå Coordinator / Dispatcher:
- You don't need dynamic routing
- Intents are few and known
- Planner already classifies intent

‚ùå LLM-Driven Delegation:
- Dangerous for execution
- Hard to audit
- Not deterministic

‚ùå Parallel Fan-Out:
- Orders & products are transactional
- Parallelism adds risk
- You value correctness over latency

‚ùå Iterative Refinement / LoopAgent:
- No iterative improvement required
- Admin commands must be single-shot

‚ùå Generator‚ÄìCritic:
- No creative output
- No subjective quality assessment

Key Principle:
Avoid patterns that add complexity without benefit or compromise safety.

==================================================
62. Final Architecture (Interview-Ready):
==================================================
Patterns Used:
1. ‚úÖ Sequential Pipeline Pattern (core)
2. ‚úÖ Policy-Based Human-in-the-Loop (safety)

Patterns Explicitly Avoided:
- Coordinator
- LLM Delegation
- LoopAgent
- ParallelAgent
- HumanAgent abstraction

Architecture Summary:
```
SequentialAgent (AdminWorkflow)
  ‚îú‚îÄ‚îÄ PlannerAgent (LlmAgent)
  ‚îÇ   ‚îî‚îÄ‚îÄ Extracts intent + entities
  ‚îÇ
  ‚îú‚îÄ‚îÄ ValidationAgent (Custom BaseAgent)
  ‚îÇ   ‚îî‚îÄ‚îÄ Guardrails + risk detection
  ‚îÇ   ‚îî‚îÄ‚îÄ Triggers HITL if needed
  ‚îÇ
  ‚îú‚îÄ‚îÄ PolicyEngine (HITL Gate)
  ‚îÇ   ‚îî‚îÄ‚îÄ Pauses if confirmation required
  ‚îÇ
  ‚îú‚îÄ‚îÄ ExecutionAgent (Custom BaseAgent)
  ‚îÇ   ‚îî‚îÄ‚îÄ Calls tools / APIs
  ‚îÇ
  ‚îî‚îÄ‚îÄ ExplanationAgent (LlmAgent)
      ‚îî‚îÄ‚îÄ Generates natural language explanations
      ‚îî‚îÄ‚îÄ Answers questions about session history
      ‚îî‚îÄ‚îÄ Explains workflow state and actions taken
```

State Flow:
- UniversalState flows through all agents
- Each agent reads/writes to shared state
- Metrics captured at each step
- HITL state managed by PolicyEngine

==================================================
63. One-Sentence Interview Answer:
==================================================
"Our system is a Sequential Workflow Agent where an LLM performs intent extraction, followed by deterministic validation and execution agents, with policy-based human-in-the-loop enforced only when guardrails trigger."

Why This Answer Works:
- Clearly states the pattern (Sequential)
- Explains LLM usage (intent extraction only)
- Emphasizes deterministic agents
- Mentions HITL as policy-based
- Shows safety-first thinking

Alternative Explanation:
"We use a Sequential Pipeline Pattern with an LlmAgent for natural language understanding, followed by deterministic validation and execution agents. Human-in-the-loop is triggered via a PolicyEngine when guardrails detect high-risk operations."

Both demonstrate:
- Clear understanding of ADK patterns
- Production-grade architecture
- Safety-first approach
- Interview-ready communication

==================================================
64. ADK Agent Tree (Visual):
==================================================
```
AdminWorkflow (SequentialAgent)
‚îÇ
‚îú‚îÄ‚îÄ Step 1: PlannerAgent (LlmAgent)
‚îÇ   ‚îú‚îÄ‚îÄ Input: Natural language
‚îÇ   ‚îú‚îÄ‚îÄ Output: {intent, entities, confidence}
‚îÇ   ‚îú‚îÄ‚îÄ Updates: universalState.state.plan
‚îÇ   ‚îî‚îÄ‚îÄ Metrics: plannerAgent metrics
‚îÇ
‚îú‚îÄ‚îÄ Step 2: ValidationAgent (Custom BaseAgent)
‚îÇ   ‚îú‚îÄ‚îÄ Input: universalState.state.plan
‚îÇ   ‚îú‚îÄ‚îÄ Checks: Guardrails, business rules
‚îÇ   ‚îú‚îÄ‚îÄ Output: {valid, riskFlag, errors}
‚îÇ   ‚îú‚îÄ‚îÄ Updates: universalState.state.validation
‚îÇ   ‚îú‚îÄ‚îÄ Triggers: HITL if needed
‚îÇ   ‚îî‚îÄ‚îÄ Metrics: validationAgent metrics
‚îÇ
‚îú‚îÄ‚îÄ Step 3: PolicyEngine (HITL Gate)
‚îÇ   ‚îú‚îÄ‚îÄ Input: universalState.state.validation
‚îÇ   ‚îú‚îÄ‚îÄ Decision: Continue or pause
‚îÇ   ‚îú‚îÄ‚îÄ If pause: Sets workflowStatus = PENDING_CONFIRMATION
‚îÇ   ‚îî‚îÄ‚îÄ If continue: Proceeds to ExecutionAgent
‚îÇ
‚îú‚îÄ‚îÄ Step 4: ExecutionAgent (Custom BaseAgent)
‚îÇ   ‚îú‚îÄ‚îÄ Input: universalState.state.validation (if valid)
‚îÇ   ‚îú‚îÄ‚îÄ Calls: Tools / Backend APIs
‚îÇ   ‚îú‚îÄ‚îÄ Output: {success, data, error}
‚îÇ   ‚îú‚îÄ‚îÄ Updates: universalState.state.execution
‚îÇ   ‚îî‚îÄ‚îÄ Metrics: executionAgent + api metrics
‚îÇ
‚îî‚îÄ‚îÄ Step 5: ExplanationAgent (LlmAgent)
    ‚îú‚îÄ‚îÄ Input: universalState.state.execution OR user questions about session
    ‚îú‚îÄ‚îÄ Uses LLM: Generate natural language explanation OR answer session history questions
    ‚îú‚îÄ‚îÄ Context: Can access full session history and workflow state
    ‚îú‚îÄ‚îÄ Output: {message, responseType}
    ‚îú‚îÄ‚îÄ Updates: universalState.state.response
    ‚îî‚îÄ‚îÄ Metrics: explanationAgent metrics
```

Key Points:
- Linear execution (SequentialAgent)
- Shared state (UniversalState)
- LLM only at boundary (PlannerAgent)
- Deterministic everywhere else
- Policy-based HITL

==================================================
65. Pattern Selection Rationale:
==================================================
Why Sequential Pipeline Pattern:

1. Matches System Requirements:
   - Step-by-step execution
   - Clear checkpoints
   - Stateful workflow
   - Safety-first approach

2. Aligns with ADK Design:
   - Google's intended usage
   - Enterprise workflow pattern
   - Production-grade architecture

3. Enables Key Features:
   - Notebook-style debugging
   - Complete traceability
   - Easy rollback/replay
   - Metrics at each step

4. Avoids Complexity:
   - No dynamic routing needed
   - No parallel execution needed
   - No iterative refinement needed

Why Policy-Based HITL:

1. Safety:
   - Deterministic decision point
   - No LLM in critical path
   - Fully auditable

2. Integration:
   - Works with guardrails
   - Integrates with UI
   - Supports confirmation flow

3. Production-Ready:
   - Google-recommended approach
   - No fake agents
   - Clean state management

This pattern selection ensures:
- Correct ADK usage
- Production-grade architecture
- Interview-ready explanation
- Maintainable codebase


==================================================
66. ExplanationAgent - Session History Questions:
==================================================
ExplanationAgent Role:
The ExplanationAgent not only generates explanations after actions but also answers questions about what happened in a particular session, regardless of whether database updates occurred.

Key Capabilities:
1. Action Explanations:
   - Generates natural language explanations after successful actions
   - Explains errors and failures
   - Provides confirmation prompts

2. Session History Questions:
   - Answers questions like "What happened in this session?"
   - Explains workflow state and actions taken
   - Provides context-aware responses based on session history
   - Handles questions regardless of database updates

How It Works:

Scenario 1 - After Action:
```
User: "Change price of SKU-001 to $49.99"
   ‚Üì
[Workflow executes]
   ‚Üì
ExplanationAgent receives: universalState.state.execution
   ‚Üì
ExplanationAgent generates: "‚úÖ Successfully updated the price..."
```

Scenario 2 - Session History Question:
```
User: "What happened in this session?"
   ‚Üì
PlannerAgent detects: QUESTION_ABOUT_SESSION intent
   ‚Üì
ExplanationAgent receives:
   - Question: "What happened in this session?"
   - Session history: universalState (all workflow states)
   ‚Üì
ExplanationAgent analyzes session history and generates:
   "In this session, you performed 2 actions:
    1) Updated the price of SKU-001 from $39.99 to $49.99
    2) Cancelled order ORD-1001"
```

Input to ExplanationAgent for Session Questions:
```typescript
{
  question: "What happened in this session?",
  sessionHistory: {
    workflows: [
      {
        workflowId: "SHOP-7788",
        intent: "UPDATE_PRODUCT_PRICE",
        status: "COMPLETED",
        data: { sku: "SKU-001", oldPrice: 39.99, newPrice: 49.99 }
      },
      {
        workflowId: "SHOP-7789",
        intent: "CANCEL_ORDER",
        status: "COMPLETED",
        data: { orderNumber: "ORD-1001" }
      }
    ],
    universalState: { /* full state */ }
  }
}
```

ExplanationAgent Processing:
1. Uses LLM to understand the question
2. Analyzes session history from universalState
3. Generates natural language summary
4. Provides context-aware explanation

Benefits:
- Users can ask questions about their session
- No need to track actions separately
- LLM provides natural, contextual responses
- Works even if no database updates occurred
- Enhances user experience with conversational interface

Example Questions ExplanationAgent Can Answer:
- "What happened in this session?"
- "What was the last action?"
- "Did I update any prices today?"
- "What orders did I cancel?"
- "Show me what I did with product SKU-001"

This makes ExplanationAgent a conversational interface that can both explain actions and answer questions about session history.
